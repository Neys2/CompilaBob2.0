options { 
	JAVA_UNICODE_ESCAPE = true; 
	KEEP_LINE_COLUMN = true; 
	STATIC = false; 
} 
/*
javacc Compilabob.jj
javac *.java
java Compilabob < Ejemplo7.txt

----------------------------------------------------------------  NOTA --------------------------------------------------------------------------
---------------------------------------------------------- MÉTODOS POR AGREGAR --------------------------------------------------------------------

Método de error "=" en lugar de ":" para las asignaciones.
Resolver el break de estructuras por el método SKIP
		Quizás funcione ampliando el rango de error hasta llaves de abertura y cierre junto a los punto y coma.

*/

PARSER_BEGIN(Compilabob) 
import java.io.*;
public class Compilabob {  
	String errormsg="\n",expresion="";
	int sentencias_inco =0;  
	//variebales para semantica-------------------------------
    String Type="", Valor=""; //variables cache para capturar el par
    String lugar = "";
	Token var;
    //--------------------------------------------------------
	public static void main(String args[])  { 
		Compilabob compilador = new Compilabob(System.in); 
		try { 
			compilador.Codigo();
		}catch( Exception e ){   
			System.out.println("\nEXCEPTION e MAIN\n" +"Sentencias incorrectas encontradas: "+compilador.sentencias_inco);
		}
		catch( TokenMgrError e ) { 
			System.out.println( "Error de Token" );
		} 
		if(compilador.errormsg == "\n" && compilador.sentencias_inco == 0){
			System.out.println("An"+"\u00e1"+"lisis l"+"\u00e9"+"xico y sint"+"\u00e1"+"ctico ejecutados con "+"\u00e9"+"xito");
		}else{
			System.out.println(compilador.errormsg);
		}
		System.out.println("\nFINAL PRINT\n" +"Sentencias incorrectas encontradas: "+compilador.sentencias_inco);
		System.out.println("----- Tabla hash ----"+ ClaseSemantica.tabla);
	}  
	
	
}   

PARSER_END(Compilabob)   

SKIP :   
{  
	< " " | "\t" | "\r" | "\n" | "\r\n" >  //White space
	| <"#" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >  //Single-line comments
	| <"##"(~["/"])*  "#""#" >  //Multi-line comments
}  

TOKEN:   
{   
<INICIO: "compilar_coatl">  //1
|<FIN: "ejecutar_coatl">  //2
|<IF: "decide">   //3
|<ELSE: "sino">   //4
|<CicloIterado: "repito hasta que">  //5
|<CicloLimit: "repito"> //6
|<CicloWhile: "mientras">  //7
|<ESCRIBIR: "muestra">//8
|<LEER:"recibir">//9
}  

TOKEN:   
{   
<ParenIzq: "(">  //10
|<ParenDer: ")"> //11
|<SepIzq: "{">  //12
|<SepDer: "}">  //13
|<PuntoComa: ";"> //14
|<COMA: ",">  //15
}  

TOKEN:  
{  
<ASIGNACION: ":"> //16
|<MENOR: "<">  //17
|<MAYOR: ">"> //18
|<MENOR_IGUAL: "<=">//19 
|<MAYOR_IGUAL: ">="> //20
|<IGUALDAD: "="> //21
|<OR: "|">  //22
|<AND: "&"> //23
|<NOTEQ: "!="> //24
|<NOT: "!"> //25
|<MAS: "+"> //26
|<MENOS: "-"> //27
|<DIV: "/"> //28
|<MODULO: "%"> //29
|<MULTI: "*"> //30
}   
// [("E_")(["a"-"z"|"A"-"Z"|"_"|"0"-"9"])+]  
//"E_"(["A"-"Z","a"-"z"](["A"-"Z","a"-"z","0"-"9"])*)  
// NOT ~ 

//<CADENAS: ("\""(~["\"","#","\n","\r","#","#","\r","\n"])*"\"")>//31

TOKEN: 
{
	<CADENAS: ("\""(~["\"","#","\n","\r","#","#","\r","\n"])*"\"")>//31
}

TOKEN: 
{ 
<ENTERO: "E_">//32
|<FLOTANTE: "D_">//33
|<NUMERO: (["0"-"9"])+>//34
|<NUMDECIMAL: (["0"-"9"])+ "." (["0"-"9"])+ | (["0"-"9"])+ "." | "." (["0"-"9"])+> //35
|<ID_CADENA: "C_">//36
|<BOOLEANO: "L_">//37
|<EST_LOGIC:("falso"|"verdad")>//38
}   

TOKEN: 
{
	<IDENTIFICADOR:["A"-"Z","a"-"z"](["A"-"Z","a"-"z","0"-"9"])*> //39

}

TOKEN: 
{ 
	<UNKNOW : ~[]> //40
}

//------------------------------- ANÁLISIS SINTACTICO - AREA DE GRAMATICAS ----------------------------------------------------

// Gramatica inicial que contiene el cuerpo basico del codigo
 void Codigo():
{
	ClaseSemantica.SetTables();	
} 
{
	((<INICIO> |ErrorNoinicio())(<SepIzq> |ErrorNoSepINICIO())) 
	Cuerpo() 
	((<SepDer>|ErrorNoSepFINAL())(<FIN>|ErrorNOFIN()))<EOF> 
} 

// método cuerpo, lee un conjunto de sentencias tamaño n
void Cuerpo():{} 
{ 
(sentencias())* 
} 

// metodo sentencias, lee todas las gramaticas que pueden ser reconocidas por el compilador
void sentencias():{} 
{ 
try {
(LOOKAHEAD(2) 
 // PuntoComa toen separado debido a la variabilidad del codigo
Declaracion()   // Declaracion de Variables k
|( Asignacion()( <PuntoComa>|errorFinlinea())) //Asignacion de valores 
| Ciclo_RepitoHastaQue() 
| Ciclo_RepitoMientras()
| Decide()
| Muestra()
| error()
| errorDOBLElinea()
  )
}
catch (ParseException e) {
	System.out.println(e.toString());  //imprime el mensaje de error
    error_skipto(PuntoComa, FIN, EOF);
  } 

}

void Muestra():{}
{

	<ESCRIBIR> <ParenIzq>  Mensaje()   <ParenDer> (<PuntoComa>|errorFinlinea())
}

void Mensaje():{}{

	Concatenacion() | {}
}

void Concatenacion():{}{

  ( LOOKAHEAD(2)
  	(<IDENTIFICADOR>|<CADENAS>) <MAS> Concatenacion() | (<IDENTIFICADOR>|<CADENAS>)) 
}

//########  DECIDE IF-ELSE ##########
void Decide():{}
{
IF() ( 
	LOOKAHEAD(2)
	ELSE()|{})

}
void IF():{ }
{
	<IF> <ParenIzq> OpComparacion() <ParenDer>  <ASIGNACION>  <SepIzq>
	(	 
	sentencias() )*
	<SepDer>
}

void ELSE():{}
{
	<ELSE> <SepIzq> 
	(	 
	sentencias() )*<SepDer> (<PuntoComa>|errorFinlinea())
}


// ############## CICLOS #############

void Ciclo_RepitoHastaQue():{}
{
	<CicloIterado> <ParenIzq> <IDENTIFICADOR> <COMA> (<IDENTIFICADOR>|DataType()) <ParenDer> <ASIGNACION> 
	<SepIzq> (sentencias())* <SepDer> (<PuntoComa>|errorFinlinea())

}

 void Ciclo_RepitoMientras():{}
{
	<CicloLimit> <ASIGNACION> <SepIzq> 
	(sentencias())* 
	<SepDer> <CicloWhile> <ParenIzq> OpComparacion() <ParenDer> (<PuntoComa>|errorFinlinea())
} 
 
// DECLARACION DE VARIABLES 
void Declaracion():{}
{
  Variable_dato(){
	int td = token.kind;
  } var = <IDENTIFICADOR>{ 
	ClaseSemantica.InsertarSimbolo(var,td);
	//System.out.println("----- Tabla hash ----"+ ClaseSemantica.tabla.toString());
  } 
  ((<ASIGNACION>  AsignacionD())|{}) (<PuntoComa>|errorFinlinea())
} 
// ASIGNACION DE VALORES DESPUES DE UNA DECLARACION
void AsignacionD():{} 
{  
	( <LEER>  | Expresion() )
} 
// ASIGNACION GENERAL DE VALORES A UNA VARIABLE
void Asignacion():
{
	Token t2;
}
{  
	var = <IDENTIFICADOR>{ 
	errormsg = errormsg+ClaseSemantica.checkVariable(var);
	if(!ClaseSemantica.checkVariable(var).equals(" ")){
		sentencias_inco = sentencias_inco+1;
	}
  }  <ASIGNACION>
	( <LEER>| expresion = Expresion().image ) {
		 
		t2 = token;
		if(token != LEER){
			Expresiones.convierte(expresion);
		}
		if(!ClaseSemantica.checkAsing(var,t2).equals(" ")){
			errormsg = errormsg+ClaseSemantica.checkAsing(var,t2);
			sentencias_inco = sentencias_inco+1;
		}
	}
} 


//###### GRAMATICA PARA EXPRESIONES MATEMATICAS DESPUES DE UNA ASIGNACION O DECLARACION
void Expresion():{} 
{   
 
	Termino() ((<MAS>|<MENOS>) Termino())*

	  
} 

// Epsilon  ---> | {}

void Termino():{}
{  
	Factor() ((<MULTI>|<DIV>|<MODULO>) Factor())*
}
void Factor():{}
{
	(<MENOS> Factor()) | Primario()
 
}

void Primario():{}
{
	((<ParenIzq>	Expresion() <ParenDer>)  | DataType() | <IDENTIFICADOR> ){
		expresion = " ";
	}
}


// ############## OPERACIONES DE COMPARACION PARA IF O CICLOS  ####################
void OpComparacion():{}{
		ExpresionL() Comparadores() ExpresionL()
}

void ExpresionL():{} 
{   LOOKAHEAD(2) 
	(  FactorL() Logicos() ExpresionL()  ) 
	  
	|  FactorL()
} 

void FactorL():{}
{
	(  DataType() | <IDENTIFICADOR> )
}

// Epsilon ---> | {}


// DATOS Y OPERADORES USADOS EN SENTENCIAS
void DataType():{} 
{ //Tipos de datos  
	 
<NUMERO> |<NUMDECIMAL> | <EST_LOGIC> | <CADENAS> 
} 
void Comparadores():{}
{
 <MENOR>   
|<MAYOR> 
|<MENOR_IGUAL>  
|<MAYOR_IGUAL>  
|<IGUALDAD> 
|<NOTEQ> 
}

void Logicos():{}
{
  <OR>  
 |<AND>  
}


void Operadores():{} 
{ //Operadores para expresiones matematicas
	LOOKAHEAD(3)
 <MAS> 
|<MENOS>  
|<DIV> 
|<MODULO>   
|<MULTI>   
} 

void Variable_dato():{} 
{ //Tipo del dato de la variable del dato a la hora de su declaracion
	LOOKAHEAD(3)
<ENTERO>   
|<FLOTANTE>   
|<ID_CADENA>   
|<BOOLEANO>  
} 
































// ---------------------------------------- TRATAMIENTO DE ERRORES --------------------------------------------------------
JAVACODE
void error_skipto(int puntocoma, int fincode, int finfile) {
  Token t;
  sentencias_inco++;
  // consume tokens all the way up to a token of "kind" - use a do-while loop
  // rather than a while because the current token is the one immediately before
  // the erroneous token (in our case the token immediately before what should
  // have been "if"/"while".
  do {
    t = getNextToken();
  }
  while ( (t.kind !=puntocoma)&&(t.kind !=fincode)&&(t.kind !=finfile));
}

void error():  
{
	String errores = " "; 
	Token t;
} 
{  
	t = <UNKNOW> 
{ 
	errores = "Simbolo: " + t.image + " no reconocido en la línea "+String.valueOf(t.beginLine)+" columna "+String.valueOf(t.endColumn)+"\r\n"; 
	errormsg = errormsg+errores; 
	sentencias_inco++;
} 
}

 
void errorFinlinea():{
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+(token.endColumn+1)+" falta ';'");
}{
	 
	{} 
	 
}
void errorDOBLElinea():{
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+(token.endColumn+1)+" hay mas de un ';'  ");
}{
	 
	 <PuntoComa>  
}


//GRAMATICAS DE ERROR PARA LA ESTRUCTURA DEL CODIGO COATL

void ErrorNoinicio():{
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+getToken(1).beginLine+" Columna: "+getToken(1).endColumn+": No hay palabra de arranque \"compilar_coatl\" ");
}{
	 
	  {} 
}

void ErrorNoSepINICIO():{
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+getToken(1).beginLine+" Columna: "+getToken(1).beginColumn+" No hay llave izquierda \"{\" ");
	sentencias_inco++;
}{
	 
	  {} 
}
void ErrorNoSepFINAL():{
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+token.beginColumn+": No hay llave derecha \"}\"");
}{
	 
	  {} 
}
void ErrorNOFIN():{
	sentencias_inco++;
	System.out.println("Error sint"+"\u00e1"+"ctico en la linea: "+token.beginLine+" Columna: "+token.beginColumn+" No hay palabra de cierre\"ejecutar_coatl\"" );
}{
	 
	  {} 
}
